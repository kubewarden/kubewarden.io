<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Towards a universal policy platform</title><link rel=icon type=image/svg href=/favicon.svg><link rel=mask-icon href=/favicon.svg><link rel=stylesheet type=text/css href=/sass/blog.min.css?1698156798><script async defer src=https://buttons.github.io/buttons.js></script><script type=text/javascript src=//cdn.bizible.com/scripts/bizible.js async></script></head><body><header><div class=sub-header><a href><img src=/images/logo-kubewarden.svg alt=Kubewarden></a>
<a href=#main-menu id=main-menu-toggle class=menu-toggle aria-label="Open main menu"><span aria-hidden=true></span><span aria-hidden=true></span><span aria-hidden=true></span></a><nav id=main-menu class=main-menu aria-label="Main menu"><a href=#main-menu-toggle id=main-menu-close class=menu-close aria-label="Close main menu"><span class=sr-only>Close main menu</span>
<span class="fa fa-close" aria-hidden=true></span></a><h2 id=main-menu-heading class=sr-only>Main menu</h2><ul class=menu><li><a href="https://artifacthub.io/packages/search?kind=13&sort=relevance&page=1" target=_blank class="btn no-bg">Policies</a></li><li><a href=https://charts.kubewarden.io/ target=_blank class="btn no-bg">Helm Charts</a></li><li><a href=https://docs.kubewarden.io/ target=_blank class="btn no-bg">Docs</a></li><li><a href="https://kubernetes.slack.com/?redir=%2Fmessages%2Fkubewarden" target=_blank class="btn no-bg">Slack</a></li><li><a href=https://twitter.com/kubewarden target=_blank class="btn no-bg">Twitter</a></li><li><a href=/blog target=_blank class="btn no-bg">Blog</a></li><li><a href=https://github.com/kubewarden class="btn github"><img src=/images/icon-github.svg><span>Github</span></a></li></ul></nav><a href=#main-menu-toggle class=backdrop tabindex=-1 aria-hidden=true hidden></a></div></header><link rel=stylesheet href=/css/blog.css><section class=intro><div class=bg-primary><div class="wrap grid-one"><div><h1 style=color:#fff><a href=/blog>The Kubewarden blog</a>
<a href=/blog/index.xml><img src=/images/icon-rss.svg class=fill-white height=20></a></h1></div></div></div></section><main><section class=wrap><article><h1>Towards a universal policy platform</h1><p>Author: <author>Flavio Castelli and Rafael FernÃ¡ndez LÃ³pez</author></p><p>Published: <time>21 Sep 2021</time></p><p>Updated: <time>24 Oct 2023</time></p><div id=blog-post-content><p>Kubewarden is a policy framework for Kubernetes. It can be used to
secure your clusters and to ensure they stay compliant with the
rules your organization establishes over time.</p><p>By leveraging the power of WebAssembly, Kubewarden allows policy authors
to write policies using traditional programming languages such as Rust, Go,
AssemblyScript and Swift.</p><p>Kubewarden policies, once compiled into WebAssembly modules, are then
distributed using regular OCI registries. This allows Operators to have a
consistent way to securely distribute both container images and policies.</p><p>Kubewarden is one of the Open Source projects working to provide a
Policy As Code solution to Kubernetes. Historically, the first project in
this space has been <a href=https://openpolicyagent.org/>Open Policy Agent</a>, also known
as &ldquo;OPA&rdquo;.</p><p>Open Policy Agent policies are written using a purpose-built query language
called <a href=https://www.openpolicyagent.org/docs/latest/policy-language/>Rego</a>.</p><p>We don&rsquo;t think there&rsquo;s a right or wrong approach when it comes to writing
policies. Both programming languages (Rust and Go) and query languages (Rego)
have advantages and disadvantages.
We strongly believe policy authors should have the freedom to pick the tool that
best suits their needs.</p><p>At the same time, we realize that this flexibility can significantly complicate
the lives of Operation teams. Simplicity is paramount when operating Kubernetes;
having different ways to distribute and enforce policies potentially
overcomplicates things.</p><p>The Kubewarden team wants to further expand the freedom of policy authors without
compromising the operation experience we currently provide.</p><p>We want to provide a cohesive way to distribute policies, a uniform
way to enforce them and a single platform to host them, regardless of
the language used to write those individual policies.</p><p>We want to provide a <strong>Universal Policy Platform</strong>.</p><h2 id=webassembly-to-the-rescue>WebAssembly to the Rescue</h2><p>Rego is a query language created by the Open Policy Agent project. The language
is inspired by <a href=https://en.wikipedia.org/wiki/Datalog>Datalog</a>; its
main purpose is to perform queries on some JSON input data and provide some
output as the response.</p><p>The good news is that Rego programs can be built into WebAssembly modules using
the official <code>opa</code> command line utility. This is documented in depth inside
of the <a href=https://www.openpolicyagent.org/docs/latest/wasm/>official documentation</a>
of Open Policy Agent.</p><p>While building a Rego program into WebAssembly is simple, running the resulting WebAssembly
module requires more effort. The good news is, we did the hard work!</p><p>We wrote a Rust library that can be used to invoke Rego policies compiled into
WebAssembly modules.
This library is called Burrego (a burrito with a Rego filling: obvious, isn&rsquo;t it?! ðŸŒ¯ ðŸ¤“)
and can be found <a href=https://github.com/kubewarden/policy-evaluator/tree/main/crates/burrego>here</a>.</p><p>The Rego language provides some <a href=https://www.openpolicyagent.org/docs/latest/policy-reference/#built-in-functions>built-in functions</a>
to help with String operations, regular expressions and many more.
When building a Rego policy into a WebAssembly module, some of these built-in
functions are going to be implemented inside of the Wasm file itself; while others
have to be provided at execution time by the WebAssembly runtime evaluating the module.</p><p>The Burrego library implements the built-in functions that are not supported natively
by the WebAssembly modules produced by <code>opa build</code>. There are still some built-ins that
Burrego does not yet provide; however, based on the policies we have seen in the open,
the ones we already support should be enough for most Kubernetes users.</p><p><a href=https://github.com/kubewarden/policy-evaluator/issues/56>This GitHub issue</a>
keeps track of the Rego built-ins we have still to implement. Feel free to
comment over there to prioritize our work.</p><h2 id=one-language-two-frameworks>One Language, Two Frameworks</h2><p>Open Policy Agent integrates with Kubernetes using the <a href=https://github.com/open-policy-agent/kube-mgmt>kube-mgmt</a>
sidecar.
More recently, a new Kubernetes integration gained popularity: <a href=https://github.com/open-policy-agent/gatekeeper>Gatekeeper</a>.</p><p>Both OPA and Gatekeeper use Rego to write their policies. However,
the way input parameters and other important information are exposed to the policy
and how the policy has to answer differs between the two.</p><p>This leads to the unfortunate situation where a Kubernetes policy written for
the OPA runtime will not work as expected if enforced by Gatekeeper, and vice versa.</p><p>We don&rsquo;t like this fragmentation in the &ldquo;Rego landscape&rdquo;. To address this, we worked to ensure
that Kubewarden can execute both policies built for OPA and Gatekeeper
<strong>without any change needed on existing policies</strong>.</p><h2 id=authoring-a-rego-policy>Authoring a Rego Policy</h2><p>Rego polices can be built into a single WebAssembly module by using the <code>opa build</code>
command. No change is required to already existing Rego policies.</p><p>We want these WebAssembly modules to be loaded by Kubewarden transparently,
so the end-users of your policy will not have to deal with the subtle differences
between a &ldquo;Kubewarden native&rdquo; policy, an OPA policy or a Gatekeeper one.
The WebAssembly module must be enriched with some Kubewarden-specific metadata
to achieve this portability.</p><p>Adding metadata to a WebAssembly module produced by <code>opa build</code> works in the
same way as modules produced by Rust and Go. This is done using the
<code>kwctl annotate</code> command.</p><p>Finally, the annotated file can be pushed to an OCI registry with the usual
<code>kwctl push</code> command.</p><p>Policy authors can also evaluate their policy locally, before pushing it, via
the <code>kwctl run</code> command.</p><p>If you are already familiar with Kubewarden, you will notice the developer
workflow stays the same, regardless of the programming language used.</p><p>All these steps are described in detail inside of our <a href=https://docs.kubewarden.io/writing-policies/rego/intro.html>documentation</a>.</p><h2 id=enforcing-a-rego-policy>Enforcing a Rego Policy</h2><p>Kubewarden policies can be enforced inside of a Kubernetes cluster by defining
a <code>ClusterAdmissionPolicy</code> object; this is a Kubernetes Custom Resource
provided by the Kubewarden project.</p><p>Operators don&rsquo;t have to bother whether the policy was built using one of Kubewarden
SDKs, OPA or Gatekeeper. The way to express settings and to enforce the policy
is always the same.</p><h2 id=wrapping-up>Wrapping Up</h2><p>We have seen what Rego is and how it relates to Open Policy Agent and
Gatekeeper. We have witnessed how combining WebAssembly with Kubewarden can smooth the
differences between the two of them.</p><p>We have also seen that the workflows of policy authors and operation teams
are uniform, regardless of the language used to write the policy.</p><p>Developer freedom and operation simplicity are top values for the Kubewarden
project. Thanks to WebAssembly we can work towards making
Kubewarden a universal policy platform.</p><p>Now the only thing we can request is to try this out! Run your Rego
policies, whether Open Policy Agent or Gatekeeper targeted, and let us
know what you think!</p><p>Also, remember to enjoy Rego and burritos!</p></div><div><ul id=tags></ul></div><div></div></article></section></main><footer><p>&copy; 2023 Kubewarden Project Authors. All rights reserved.
The Linux Foundation has registered trademarks and uses trademarks.
For a list of trademarks of The Linux Foundation, please see our Trademark Usage page:
<a href=https://www.linuxfoundation.org/trademark-usage>https://www.linuxfoundation.org/trademark-usage</a></p><div class=project-icons><a href=https://k3s.io target=blank><img src=/images/icon-k3s.svg height=20></a>
<a href=https://harvesterhci.io target=blank><img src=/images/icon-harvester.svg height=20></a>
<a href=https://rancherdesktop.io target=blank><img src=/images/icon-rancher-desktop.svg height=20></a>
<a href=https://epinio.io target=blank><img src=/images/icon-epinio.svg height=20></a>
<a href=https://hypper.io target=blank><img src=/images/icon-hypper.svg height=20></a></div></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-56382716-13','auto'),ga('set','anonymizeIp',!0),ga('send','pageview'))</script></body></html>